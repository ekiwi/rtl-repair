// Copyright 2020 The Regents of the University of California
// released under BSD 3-Clause License
// author: Kevin Laeufer <laeufer@cs.berkeley.edu>

package maltese.mc

import maltese.smt.SMTLibSerializer
import org.scalatest.flatspec.AnyFlatSpec

class Btor2ParserSpec extends AnyFlatSpec {
  // this example if from the official btor2tools repository
  private val count2 =
    """1 sort bitvec 3
      |2 zero 1
      |3 state 1
      |4 init 1 3 2
      |5 one 1
      |6 add 1 3 5
      |7 next 1 3 6
      |8 ones 1
      |9 sort bitvec 1
      |10 eq 9 3 8
      |11 bad 10
      |""".stripMargin

  it should "parse count2 w/o inlining" in {
    val expected =
      """counter2
        |node s2 : bv<3> = 3'b0
        |init _state_0.init : bv<3> = s2
        |node s5 : bv<3> = 3'b1
        |node s6 : bv<3> = add(_state_0, s5)
        |next _state_0.next : bv<3> = s6
        |node s8 : bv<3> = 3'b111
        |node s10 : bv<1> = eq(_state_0, s8)
        |bad _bad_0 : bv<1> = s10
        |state _state_0 : bv<3>
        |  [init] _state_0.init
        |  [next] _state_0.next
        |""".stripMargin
    val sys = Btor2.read(count2, inlineSignals = false, defaultName = "counter2").serialize
    assert(sys.trim == expected.trim)
  }

  it should "parse count2 with inlining" in {
    val expected =
      """counter2
        |bad _bad_0 : bv<1> = eq(_state_0, 3'b111)
        |state _state_0 : bv<3>
        |  [init] 3'b0
        |  [next] add(_state_0, 3'b1)
        |""".stripMargin
    val sys = Btor2.read(count2, inlineSignals = true, defaultName = "counter2").serialize
    assert(sys.trim == expected.trim)
  }

  // this example if from the official btor2tools repository
  private val twocount2 =
    """1 sort bitvec 1
      |2 sort bitvec 2
      |3 input 1 turn
      |4 zero 2
      |5 state 2 a
      |6 state 2 b
      |7 init 2 5 4
      |8 init 2 6 4
      |9 one 2
      |10 add 2 5 9
      |11 add 2 6 9
      |12 ite 2 3 5 10
      |13 ite 2 -3 6 11
      |14 next 2 5 12
      |15 next 2 6 13
      |16 ones 2
      |17 eq 1 5 16
      |18 eq 1 6 16
      |19 and 1 17 18
      |20 bad 19
      |""".stripMargin

  it should "parse twocount2 which uses negative node ids" in {
    val expected =
      """twocount2
        |input turn : bv<1>
        |bad _bad_0 : bv<1> = and(eq(a, 2'b11), eq(b, 2'b11))
        |state a : bv<2>
        |  [init] 2'b0
        |  [next] ite(turn, a, add(a, 2'b1))
        |state b : bv<2>
        |  [init] 2'b0
        |  [next] ite(not(turn), b, add(b, 2'b1))
        |""".stripMargin

    val sys = Btor2.read(twocount2, inlineSignals = true, defaultName = "twocount2").serialize
    assert(sys.trim == expected.trim)
  }

  it should "parse yosys output from Verilog conversion" in {
    val src =
      """; BTOR description generated by Yosys 0.18+29 (git sha1 b2408df31, clang 10.0.0-4ubuntu1 -fPIC -Os) for module first_counter.
        |1 sort bitvec 1
        |2 input 1 enable ; first_counter.v:4.11-4.17
        |3 input 1 reset ; first_counter.v:3.11-3.16
        |4 input 1 clock ; first_counter.v:2.11-2.16
        |5 state 1
        |6 output 5 overflow_out ; first_counter.v:6.16-6.28
        |7 sort bitvec 4
        |8 state 7
        |9 output 8 counter_out ; first_counter.v:5.22-5.33
        |10 const 1 0
        |11 ite 1 3 10 5 $procmux$7 ; first_counter.v:9.8-9.21|first_counter.v:9.5-13.8
        |12 const 1 1
        |13 const 7 1111
        |14 eq 1 8 13 $eq$first_counter.v:14$5 ; first_counter.v:14.8-14.30
        |15 ite 1 14 12 11 $procmux$9 ; first_counter.v:14.8-14.30|first_counter.v:14.5-16.8
        |16 next 1 5 15 $procdff$17 ; first_counter.v:8.1-17.4
        |17 sort bitvec 32
        |18 uext 17 8 28
        |19 const 17 00000000000000000000000000000001
        |20 add 17 18 19 $add$first_counter.v:12$4 ; first_counter.v:12.24-12.39
        |21 slice 7 20 3 0
        |22 ite 7 2 21 8 $procmux$11 ; first_counter.v:11.17-11.31|first_counter.v:11.14-13.8
        |23 ite 7 3 8 22 $procmux$14 ; first_counter.v:9.8-9.21|first_counter.v:9.5-13.8
        |24 next 7 8 23 $procdff$16 ; first_counter.v:8.1-17.4
        |; end of yosys output
        |""".stripMargin

    val sys = Btor2.read(src, defaultName = "first_counter", inlineSignals = true)
    val doPrint = false
    sys.states.foreach { st =>
      st.next.foreach { next =>
        if (doPrint) println(SMTLibSerializer.serialize(next))
      }
    }

    if (doPrint) println(sys.serialize)
  }

}
