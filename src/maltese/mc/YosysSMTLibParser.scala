// Copyright 2022 The Regents of the University of California
// released under BSD 3-Clause License
// author: Kevin Laeufer <laeufer@cs.berkeley.edu>

package maltese.mc

import maltese.smt._

/** Parses Transitions Systems serialized by yosys's `write_smt2` command */
object YosysSMTLibParser {
  def load(file: os.Path): TransitionSystem = {
    val defaultName = file.last.split('.').dropRight(1).mkString(".")
    read(os.read.lines(file), defaultName)
  }
  def read(lines: Iterable[String], defaultName: String = ""): TransitionSystem = {
    new YosysSMTLibParser(lines).read()
  }
}

private class YosysSMTLibParser(lines: Iterable[String]) {

  private var sys: Option[TransitionSystem] = None
  def read(): TransitionSystem = {
    sys.getOrElse(parse())
  }

  private def parse(): TransitionSystem = {
    val content = lines.map(parseLine).filterNot(_.isEmpty)
    parseContent(content)
  }

  private val YosysHeaderPrefix = "SMT-LIBv2 description generated by Yosys"
  private def parseContent(content: Iterable[LineContent]): TransitionSystem = {
    // look for yosys file header
    assert(content.head.expr.isEmpty, "unexpected S-Expr in first line!")
    val header = content.head.comment
    assert(header.startsWith(YosysHeaderPrefix), s"unexpected header comment: $header")
    val yosysVersion = header.drop(YosysHeaderPrefix.length).trim
    println(s"Yosys Version: $yosysVersion")

    val startSys = TransitionSystem("", List(), List(), List())
    content.drop(1).foldLeft(startSys)(parseLineContent)
  }

  private val YosysDescriptorPrefix = "yosys-smt2-"
  private def parseLineContent(sys: TransitionSystem, line: LineContent): TransitionSystem = {
    if(line.expr.isEmpty) {
      if(line.comment.startsWith(YosysDescriptorPrefix)) {
        val suffix = line.comment.drop(YosysDescriptorPrefix.length)
        val desc = suffix.split(' ').head.trim
        val value = suffix.split(' ').drop(1).mkString(" ")
        desc match {
          case "module" =>
            assert(sys.name.isEmpty, s"we are being asked to overwrite the system name ${sys.name} with $value")
            sys.copy(name = value.trim)
          case other => throw new NotImplementedError(s"unknown yosys descriptor: $other")
        }
      } else {
        println(s"Unknown comment: ${line.comment}")
        sys
      }
    } else { // we have a non-empty expression
      val expr = parseSmtCommand(line.expr)
      expr match {
        case DeclareUninterpretedSort(_) =>
          assert(line.comment.isEmpty)
          sys // ignore data type declaration
        case DeclareFunction(sym, args) =>
          assert(args.length == 1, "expect every function to take the state as argument")
          println(s"TODO: deal with function declaration $sym")
          sys // ignore function declaration for now....
      }
    }
  }

  private def parseComment(sys: TransitionSystem, comment: String): TransitionSystem = {
    ???
  }

  private def parseSmtCommand(expr: SExpr): SMTCommand = {
    expr match {
      case SExprNode(List(SExprLeaf("declare-sort"), SExprLeaf(name), SExprLeaf("0"))) =>
        DeclareUninterpretedSort(SMTLibSerializer.unescapeIdentifier(name))
      case SExprNode(List(SExprLeaf("declare-fun"), SExprLeaf(name), SExprNode(args), retTpe)) =>
        val sym = SMTSymbol.fromType(SMTLibSerializer.unescapeIdentifier(name), parseSmtType(retTpe))
        val argTpes = args.map(parseSmtType)
        assert(argTpes.forall(_.isInstanceOf[UninterpretedSort]), s"expected only unintepreted sort args! $argTpes")
        DeclareFunction(sym, argTpes.map(a => UTSymbol("", a.asInstanceOf[UninterpretedSort].name)))
      case other => throw new RuntimeException(s"Unexpected S-Expr: $other")
    }
  }

  private def parseSmtType(expr: SExpr): SMTType = expr match {
    case SExprLeaf("Bool") => BVType(1)
    case SExprLeaf(name) => UninterpretedSort(SMTLibSerializer.unescapeIdentifier(name))
    case other => throw new NotImplementedError(s"TODO: parse SMT type $other")
  }

  private def parseSmtExpr(expr: SExpr): SMTExpr = {
    ???
  }

  private case class LineContent(expr: SExpr, comment: String) {
    def isEmpty = comment.isEmpty && expr.isEmpty
  }
  private def parseLine(line: String): LineContent = {
    val parts = line.split(';')
    val exprStr = parts.head.trim
    val comment = parts.drop(1).mkString(";").trim
    LineContent(expr = SExprParser.parse(exprStr), comment = comment)
  }
}